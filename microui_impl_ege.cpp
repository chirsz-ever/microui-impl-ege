#include <ege.h>
#include <assert.h>
#include <cstdio>
#include <string>
#include <cmath>
#include <gdiplus.h>
#include "microui_impl_ege.h"

#define ATLAS_WIDTH    41
#define ATLAS_HEIGHT   18

const unsigned char atlas_texture[ATLAS_WIDTH * ATLAS_HEIGHT] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x8f,
	0x00, 0x00, 0x00, 0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x8f, 0xff, 0x8f, 0x00, 0x8f, 0xff, 0x8f, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0x8f,
	0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x14, 0x5c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5c, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x8f, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e,
	0xff, 0x70, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0x5e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x20, 0xc0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0x70, 0x00, 0x00, 0x70, 0xff,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xe0, 0xea, 0x2c, 0x00, 0x00, 0xff,
	0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
	0xff, 0x70, 0x70, 0xff, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xe0, 0xea,
	0x2d, 0x00, 0x00, 0x00, 0x8f, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0xff, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x21, 0xe1, 0xeb, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff,
	0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff,
	0xff, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xe1, 0xeb, 0x2d, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x70, 0xff, 0x70, 0x70, 0xff, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3d, 0xed, 0x45, 0x00, 0x00, 0x00, 0x22, 0xe1, 0xeb,
	0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0x8f, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0x70, 0x00, 0x00, 0x70,
	0xff, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xd0, 0xf6, 0x45,
	0x00, 0x22, 0xe1, 0xeb, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8f, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0xff,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0x5e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x13, 0xd0, 0xf6, 0x63, 0xe1, 0xeb, 0x2e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c,
	0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xd0, 0xff, 0xec,
	0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x13, 0xbc, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const mu_Rect atlas[] = {
	{ 0 },
	{  0, 0, 16, 16 },     // MU_ICON_CLOSE
	{ 16, 0, 18, 18 },     // MU_ICON_CHECK
	{ 18 + 16, 5, 5, 7 },  // MU_ICON_COLLAPSED
	{ 18 + 16, 0, 7, 5 },  // MU_ICON_EXPANDED
};

const size_t INPUTBUFSIZE = 128;

static char* ansi2utf8(const char ansistr[], int len, char dest[], size_t bufsize) {
	wchar_t wcbuf[INPUTBUFSIZE];
	int wclen = ::MultiByteToWideChar(CP_ACP, 0, ansistr, len, wcbuf, INPUTBUFSIZE);
	wcbuf[wclen] = '\0';
	int clen = ::WideCharToMultiByte(CP_UTF8, 0, wcbuf, wclen, dest, bufsize, NULL, NULL);
	dest[clen] = '\0';
	return dest;
}

static std::wstring utf82utf16(const char u8str[], int len) {
	int bufsize = MultiByteToWideChar(CP_UTF8, 0, u8str, len, NULL, 0);
	std::wstring wStr(bufsize, UNICODE_NULL);
	MultiByteToWideChar(CP_UTF8, 0, u8str, len, &wStr[0], bufsize);
	return wStr;
}

// TODO: 继续改进
static int microui_impl_ege_text_width(mu_Font font, const char *text, int len) {
	Gdiplus::Graphics graphics(ege::getHDC());
	Gdiplus::Font gfont(ege::getHDC());
	Gdiplus::StringFormat stringFormat(Gdiplus::StringFormat::GenericTypographic());
	stringFormat.SetTrimming(Gdiplus::StringTrimmingNone);
	stringFormat.SetFormatFlags(stringFormat.GetFormatFlags()|Gdiplus::StringFormatFlagsMeasureTrailingSpaces);
	stringFormat.SetAlignment(Gdiplus::StringAlignmentCenter);
	Gdiplus::RectF boundingBox;
	Gdiplus::SizeF boundingBoxSize;
	const std::wstring& outtext = utf82utf16(text, len);
	graphics.MeasureString(
		outtext.c_str(),
		-1,
		&gfont,
		Gdiplus::PointF(),
		&stringFormat,
		&boundingBox
	);
	boundingBox.GetSize(&boundingBoxSize);
	return round(boundingBoxSize.Width);
}


static int microui_impl_ege_text_height(mu_Font font) {
	Gdiplus::Font gfont(ege::getHDC());
	return gfont.GetHeight(::GetDeviceCaps(ege::getHDC(), LOGPIXELSY));
}

void microui_impl_ege_init(mu_Context *ctx) {

	// 字体设置
	ege::setfont(
	    16,
	    0,
	    "Gadugi",
	    0,
	    0,
	    0,
	    false,
	    false,
	    false,
	    DEFAULT_CHARSET,
	    OUT_DEFAULT_PRECIS,
	    CLIP_DEFAULT_PRECIS,
	    NONANTIALIASED_QUALITY,
	    DEFAULT_PITCH
	);
	ctx->text_width = microui_impl_ege_text_width;
	ctx->text_height = microui_impl_ege_text_height;
}

static mu_Vec2 real_pos(int px, int py) {
	static int orgn_x, orgn_y;
	ege::getviewport(&orgn_x, &orgn_y, NULL, NULL);
	return mu_vec2(px - orgn_x, py - orgn_y);
}

static void r_draw_rect(mu_Rect rect, mu_Color color) {
	mu_Vec2 r_pos = real_pos(rect.x, rect.y);
	ege::setfillcolor(EGERGBA(color.r, color.g, color.b, color.a), nullptr);
	ege::ege_fillrect(r_pos.x, r_pos.y, rect.w, rect.h, nullptr);
}

static void r_draw_text(const char *text, mu_Vec2 pos, mu_Color color) {
	mu_Vec2 r_pos = real_pos(pos.x, pos.y);
	const std::wstring& outtext = utf82utf16(text, -1);

	if (*text) { //宽度为0时bug
		const ege::color_t textcolor = EGERGBA(color.r, color.g, color.b, color.a);
		ege::setcolor(textcolor);
		ege::ege_drawtext(outtext.c_str(), r_pos.x, r_pos.y);
	}
}

static void r_draw_icon(int id, mu_Rect rect, mu_Color color) {
	const mu_Vec2 r_pos = real_pos(rect.x, rect.y);
	const mu_Rect tex_src = atlas[id];
	const int px = r_pos.x + (rect.w - tex_src.w) / 2;
	const int py = r_pos.y + (rect.h - tex_src.h) / 2;
	const ege::color_t base_color = EGERGB(color.r, color.g, color.b);

	for (int y = 0; y < tex_src.h; ++y) {
		const unsigned char* tex_pix = atlas_texture + (tex_src.y + y) * ATLAS_WIDTH + tex_src.x;
		for (int x = 0; x < tex_src.w; ++x) {
			const unsigned char alpha = unsigned(*tex_pix) * color.a / 255;
			ege::putpixel_withalpha(px + x, py + y, EGECOLORA(base_color, alpha));
			++tex_pix;
		}
	}

}

static void r_set_clip_rect(mu_Rect rect) {
	// EGE 的视图裁剪范围不包括最右列和最下行
	// 见 https://xege.org/manual/api/env/setviewport.htm
	ege::setviewport(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h);
}

void microui_impl_ege_draw_data(mu_Context *ctx) {
	mu_Command *cmd = NULL;
	while (mu_next_command(ctx, &cmd)) {
		switch (cmd->type) {
		case MU_COMMAND_TEXT: r_draw_text(cmd->text.str, cmd->text.pos, cmd->text.color); break;
		case MU_COMMAND_RECT: r_draw_rect(cmd->rect.rect, cmd->rect.color); break;
		case MU_COMMAND_ICON: r_draw_icon(cmd->icon.id, cmd->icon.rect, cmd->icon.color); break;
		case MU_COMMAND_CLIP: r_set_clip_rect(cmd->clip.rect); break;
		}
	}
}


void microui_impl_ege_shutdown() {

}

static int ege2mu_key_map(int key) {
	int res;
	using namespace ege;
	switch (key)
	{
	case key_shift:
	case key_shift_l:
	case key_shift_r:
		res = MU_KEY_SHIFT;
		break;
	case key_control:
	case key_control_l:
	case key_control_r:
		res = MU_KEY_CTRL;
		break;
	case key_menu:
	case key_menu_l:
	case key_menu_r:
		res = MU_KEY_ALT;
		break;
	case key_enter:
		res = MU_KEY_RETURN;
		break;
	case key_back:
		res = MU_KEY_BACKSPACE;
		break;
	default:
		res = 0;
	}
	return res;
}

static void microui_impl_ege_process_mouse_events(mu_Context *ctx) {
	while (ege::mousemsg()) {
		ege::mouse_msg mmsg = ege::getmouse();
		if (mmsg.is_move()) {
			mu_input_mousemove(ctx, mmsg.x, mmsg.y);
		}
		else if (mmsg.is_wheel()) {
			mu_input_scroll(ctx, 0, -mmsg.wheel / 10);
		}
		else if (mmsg.is_left()) {
			if (mmsg.is_down())
				mu_input_mousedown(ctx, mmsg.x, mmsg.y, MU_MOUSE_LEFT);
			else if (mmsg.is_up())
				mu_input_mouseup(ctx, mmsg.x, mmsg.y, MU_MOUSE_LEFT);
		}
		else if (mmsg.is_right()) {
			if (mmsg.is_down())
				mu_input_mousedown(ctx, mmsg.x, mmsg.y, MU_MOUSE_RIGHT);
			else if (mmsg.is_up())
				mu_input_mouseup(ctx, mmsg.x, mmsg.y, MU_MOUSE_RIGHT);
		}
		else if (mmsg.is_mid()) {
			if (mmsg.is_down())
				mu_input_mousedown(ctx, mmsg.x, mmsg.y, MU_MOUSE_MIDDLE);
			else if (mmsg.is_up())
				mu_input_mouseup(ctx, mmsg.x, mmsg.y, MU_MOUSE_MIDDLE);
		}
	}
}

static void microui_impl_ege_process_keyboard_events(mu_Context * ctx) {
	static char cbuf[INPUTBUFSIZE * 3] = " ";
	static wchar_t wcbuf[INPUTBUFSIZE] = L" ";
	static char mbcsbuf[INPUTBUFSIZE * 2] = " ";
	int len = 0;
	bool is_unicode_win = IsWindowUnicode(ege::getHWnd());

	while (ege::kbmsg()) {
		ege::key_msg kmsg = ege::getkey();
		switch (kmsg.msg)
		{
		case ege::key_msg_char: {
			switch (kmsg.key)
			{
			case '\n':
			case '\r':
			case '\b':
			case '\t':
				break;
			default:
				if (is_unicode_win) {
					wcbuf[len++] = kmsg.key;
				} else {
					mbcsbuf[len++] = kmsg.key;
				}
			}
			break;
		}
		case ege::key_msg_down: {
			int c = ege2mu_key_map(kmsg.key);
			if (c)
				mu_input_keydown(ctx, c);
			break;
		}
		case ege::key_msg_up: {
			int c = ege2mu_key_map(kmsg.key);
			if (c)
				mu_input_keyup(ctx, c);
			break;
		}
		}
	}
	if (len) {
		if (is_unicode_win) {
			size_t bytes = ::WideCharToMultiByte(CP_UTF8, 0, wcbuf, len, cbuf, INPUTBUFSIZE * 3, NULL, NULL);
			if (bytes < INPUTBUFSIZE * 3) {
				cbuf[bytes] = '\0';
			}
		} else {
			mbcsbuf[len] = '\0';
			ansi2utf8(mbcsbuf, -1, cbuf, INPUTBUFSIZE * 3);
		}
		mu_input_text(ctx, cbuf);
	}

}

void microui_impl_ege_process_events(mu_Context *ctx) {
	microui_impl_ege_process_mouse_events(ctx);
	microui_impl_ege_process_keyboard_events(ctx);
}
